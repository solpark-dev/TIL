# [Android] Thread와 UI 업데이트 처리 방법 총정리

**날짜:** 2025-11-13
**태그:** #Android #Java #Thread #Handler #ANR

---

## 1. 학습 배경: 왜 스레드가 필요한가?
안드로이드의 **Main Thread(UI Thread)**는 화면 그리기와 터치 이벤트를 담당한다. 만약 여기서 `Thread.sleep()`이나 무거운 연산을 수행하면 화면이 멈추는 **ANR(Application Not Responding)** 현상이 발생한다.

따라서, **오래 걸리는 작업은 별도의 Worker Thread(백그라운드 스레드)**에서 처리해야 한다.

> **주의:** Worker Thread에서는 UI(TextView 등)를 직접 변경할 수 없다. 변경 시 앱이 강제 종료된다 (`CalledFromWrongThreadException`).

---

## 2. 단계별 구현 및 발전 과정

### Step 1. 문제 상황과 임시 방편 (Thread02)
* **상황:** Main Thread에서 10초간 루프를 돌리면 앱이 멈춘다.
* **학원 예제 방식:**
    * Worker Thread는 숫자만 증가시킴.
    * **Polling 방식:** 버튼을 누를 때만(`onClick`) 스레드의 값을 `getter`로 가져와서 UI에 반영.
    * *단점:* 실시간으로 값이 변하는 것을 볼 수 없음.

### Step 2. Handler와 Message 사용 (Thread05 - Standard)
* **해결책:** `Handler`를 이용해 Worker Thread에서 Main Thread로 메시지를 보낸다.
* **최적화 (obtainMessage):**
    * `new Message()` 대신 `handler.obtainMessage()`를 사용하여 **객체를 재사용(Recycling)**, 메모리 효율을 높임.
    * `arg1`(정수), `obj`(문자열/객체) 등 다양한 데이터를 담을 수 있음.
    * **Inner Class**로 구현하여 파일 관리를 단순화.

```java
// Worker Thread 내부
String msgData = "Count: " + count;
// 1. 메시지 얻기(obtain) -> 2. 데이터 담기 -> 3. 보내기(sendToTarget)
handler.obtainMessage(1, count, 0, msgData).sendToTarget();

// Main Activity 내부 (Handler)
handler = new Handler(Looper.getMainLooper()) {
    @Override
    public void handleMessage(@NonNull Message msg) {
        if (msg.what == 1) {
            String data = (String) msg.obj; // obj 꺼내기
            textView.setText(data);
        }
    }
};

```

### Step 3. Handler.post 사용 (Thread06 - Simple)

* **특징:** `Message` 객체를 생성하거나 `handleMessage`를 오버라이딩할 필요가 없다.
* **방식:** 실행할 코드 덩어리인 `Runnable` 객체 자체를 핸들러에게 던진다.
* **장점:** 코드가 직관적이며, 단순한 UI 갱신에 유리하다.

```java
// Worker Thread 내부에서 호출
handler.post(new Runnable() {
    @Override
    public void run() {
        // 이 블록 안의 코드는 Main Thread(UI Thread)에서 실행됨을 보장받음
        textView.setText("Count: " + count);
    }
});
```

### Step 4. runOnUiThread 사용 (Thread07 - Simplest)

* **특징:** `Activity` 클래스가 제공하는 내장 메서드이다. `Handler` 객체를 선언할 필요조차 없다.
* **장점:** 액티비티 내부에서 가장 간편하고 빠르게 UI를 갱신하는 방법이다.

```java
// Worker Thread 내부에서 호출
runOnUiThread(new Runnable() {
    @Override
    public void run() {
        // Main Thread에서 실행됨을 보장받음
        textView.setText("Count: " + count);
    }
});
```
---

### Part 3. 요약 및 컨벤션 체크 (Summary)


## 3. 요약 및 비교

| 방식 | 클래스/메서드 | 특징 | 추천 상황 |
| :--- | :--- | :--- | :--- |
| **Message** | `handler.sendMessage` | `what`, `arg`, `obj` 등으로 데이터를 분류해서 전달 | 데이터를 가공하거나 분기 처리가 필요할 때 |
| **Post** | `handler.post` | `Runnable` 객체(코드 블록)를 전달 | 단순 UI 업데이트만 필요할 때 |
| **UI Util** | `runOnUiThread` | 핸들러 선언 불필요 (Activity 메서드) | 액티비티 내에서 가장 빠르게 구현할 때 |

## 4. Code Convention (Self-Check)

* [x] `int` 변수 선언 시 `0`으로 초기화 (`int count = 0;`)
* [x] `String` 변수 선언 시 `""`으로 초기화 (`String text = "";`)
* [x] 로그 확인을 위한 `Log` 또는 `System.out.println` 활용
* [x] `onDestroy`에서 스레드 종료 처리 (`stopThread`)
