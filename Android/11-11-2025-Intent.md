# 2025년 11월 11일 오늘 배운 내용 (TIL)

오늘은 안드로이드의 이벤트 처리 심화 과정과 `Activity` 및 `Intent`의 핵심 개념에 대해 깊이 있게 학습했다.

---

## ⚡ 1. 안드로이드 이벤트 심화

### OnClickListener 구현 3가지 방법

1.  **익명 내부 클래스 (Anonymous Inner Class)**: `button.setOnClickListener(new OnClickListener() { ... })`
    * 가장 일반적이며, 각 버튼에 고유한 로직을 구현할 때 유용하다.
2.  **XML `android:onClick` 속성**: `android:onClick="xmlOnClick"`
    * Activity에 `public void xmlOnClick(View v)` 메서드를 구현해야 한다.
    * 코드가 간결해지지만, `Fragment` 등에서는 사용이 복잡해질 수 있다.
3.  **멤버 변수 (Has-a 관계)**: `private OnClickListener listener = new OnClickListener() { ... }`
    * 리스너 객체를 **하나만** 생성하고, 여러 버튼이 **공유(재사용)**할 수 있다.
    * `onClick(View v)` 내부에서 `v.getId()`로 어떤 버튼이 눌렸는지 식별해야 한다. (`if-else`문 사용, `switch`는 `R.id`가 상수가 아니라 에러 발생)

### 이벤트 처리 우선순위 (Event Priority)

하나의 `View`에 여러 이벤트가 동시에 등록된 경우, **터치(Touch) 이벤트가 가장 높은 우선순위**를 가진다.

* **실행 순서**: `OnTouch` → `OnLongClick` → `OnClick`
* **`boolean onTouch(View v, MotionEvent event)`의 리턴 값**
    * `return false;` (기본값): "내가(Touch) 이벤트를 처리했지만, 이 이벤트를 다음 리스너에게 **전달(전파)하겠다**."
        * `ACTION_DOWN`에서 `false`를 반환해야 `OnLongClick`이나 `OnClick`이 정상적으로 이어서 호출될 수 있다.
    * `return true;`: "내가(Touch) 이벤트를 **완전히 소비(Consume)하겠다**."
        * `OnLongClick`이나 `OnClick`이 **절대 호출되지 않는다.**
* **`boolean onLongClick(View v)`의 리턴 값**
    * `return true;`: "내가(LongClick) 이벤트를 소비하겠다."
        * `OnClick` 이벤트가 **호출되지 않는다.** (꾹 눌렀다 떼도 `OnClick` 무시)
    * `return false;`: "이벤트를 전달하겠다."
        * 꾹 눌렀다 떼면 `OnLongClick` 실행 후 `OnClick`도 **이어서 실행**된다.

---

## 📱 2. 시스템 서비스 및 권한

* **`Vibrator` (진동)**:
    * `getSystemService(Context.VIBRATOR_SERVICE)`로 객체를 얻어온다.
    * API 26 (오레오) 이상은 `VibrationEffect`를, 미만은 `vibrator.vibrate(milliseconds)`를 사용하도록 분기 처리(`Build.VERSION.SDK_INT`)가 필요하다.
    * **에뮬레이터**에서는 하드웨어가 없어 `VibratorService command failed` 에러가 발생할 수 있으나, 코드는 정상이다.
* **`AndroidManifest.xml` (매니페스트)**:
    * 진동, 인터넷, 전화 걸기 등 시스템 기능을 사용하려면 반드시 권한을 명시해야 한다.
    * `<uses-permission android:name="android.permission.VIBRATE" />`
* **`onDestroy()`**:
    * Activity가 소멸될 때 호출된다.
    * `Vibrator`나 `View` 객체 참조를 `null`로 설정하여 메모리 누수(Memory Leak)를 방지하는 것이 좋다.

---

## 🚀 3. Activity와 Intent 기본

### Activity 내 화면 전환 (`Intent01`)

* `FrameLayout`을 사용하면 여러 레이아웃(페이지)을 겹쳐서 배치할 수 있다.
* `page1.setVisibility(View.VISIBLE);` (보이기)
* `page2.setVisibility(View.INVISIBLE);` (숨기기, 자리는 차지함)
* `Intent` 없이 **하나의 Activity 내에서** 화면을 전환하는 효과를 낼 수 있다.

### Activity 간 화면 전환 (명시적 인텐트, `Intent02`)

* **`Intent` (인텐트)**: Activity 등 컴포넌트 간 통신을 위한 "명령서" 또는 "메시지 객체".
* **명시적 인텐트 (Explicit Intent)**: `new Intent(this, **SecondActivity.class**);`
    * "누가" 받을지(`SecondActivity.class`) 명확하게 지정한다. **(내 앱 내부 이동)**
* **Activity 스택 (Stack)**: Activity는 스택(LIFO) 구조로 쌓인다.
    * **`startActivity(intent)`**: 스택의 맨 위에 새 Activity를 쌓는다. (1번 위 2번, 2번 위 3번)
    * **`finish()`**: 현재 Activity를 스택에서 제거(Pop)한다. (3번 종료 → 2번 보임, 2번 종료 → 1번 보임)

---

## 💾 4. Activity 생명주기와 상태 저장

### Activity Lifecycle (`Intent02-LifeCycle`)

Activity는 생성부터 소멸까지 정해진 생명주기를 가지며, 각 시점에 콜백 메서드가 호출된다.

* **`onCreate()`**: 생성 (1회)
* **`onStart()`**: 화면에 보이기 직전
* **`onResume()`**: 사용자와 상호작용 가능 (활성화)
* --- (실행 중) ---
* **`onPause()`**: 포커스를 잃음 (다른 Activity가 올라오기 시작)
* **`onStop()`**: 화면에서 완전히 가려짐
* **`onDestroy()`**: 소멸 (1회)
* **`onRestart()`**: `onStop` 상태에서 다시 화면에 불려 나올 때

> **[관찰] `startActivity` (1번 → 2번)**
> 1.  `First: onPause()`
> 2.  `Second: onCreate()` → `onStart()` → `onResume()`
> 3.  `First: onStop()`
>
> **[관찰] `finish` (2번 → 1번)**
> 1.  `Second: onPause()`
> 2.  `First: onRestart()` → `onStart()` → `onResume()`
> 3.  `Second: onStop()` → `onDestroy()`

### Activity 상태 저장 (`Intent03`)

* **`onSaveInstanceState(Bundle outState)`**: Activity가 **강제 종료** (예: **화면 회전**, 메모리 부족)될 때 호출됨. (`finish()` 시에는 호출 안 됨)
    * `outState.putString("key", "저장할 값");`
* **`onRestoreInstanceState(Bundle savedState)`**: `onCreate` 다음에 호출되며, 저장된 `Bundle`을 전달받아 상태를 **복원**한다.
    * `String value = savedState.getString("key");`

---

## 📦 5. Intent를 이용한 데이터 통신 (`Intent04`)

`Intent`는 "데이터 가방"으로도 사용된다.

### 단방향 데이터 전달 (A → B)

* **(A) 보내는 쪽:**
    * `intent.putExtra("key", "보낼 값");` // "key"는 이름표
    * `startActivity(intent);`
* **(B) 받는 쪽 (`onCreate`에서):**
    * `Intent intent = getIntent();` // 나를 실행시킨 Intent를 가져옴
    * `String value = intent.getStringExtra("key");`

### 양방향 데이터 전달 (A ↔ B) (결과 돌려받기)

* **(A) 요청하는 쪽:**
    * `int REQUEST_CODE = 1004;` // 요청을 식별하기 위한 고유 ID
    * `startActivityForResult(intent, REQUEST_CODE);` // `startActivity` 대신 사용
    * `onActivityResult(...)` 메서드를 오버라이드하여 결과를 기다린다.
* **(B) 응답하는 쪽:**
    * (작업 수행 후 "Close" 버튼 클릭 시)
    * `Intent resultIntent = new Intent();` // 데이터를 담을 빈 가방 생성
    * `resultIntent.putExtra("resultKey", "결과 값");`
    * `setResult(RESULT_OK, resultIntent);` // "성공" 코드와 "결과 가방"을 설정
    * `finish();` // 종료
* **(A) 결과 받는 쪽:**
    * `onActivityResult(int requestCode, int resultCode, Intent data)`가 **자동 호출**됨.
    * `if (requestCode == REQUEST_CODE && resultCode == RESULT_OK)`
    * `String result = data.getStringExtra("resultKey");`

---

## 🌐 6. 묵시적 인텐트 (Implicit Intent) (`Intent05`)

* **명시적 인텐트**: "내 앱의 `SecondActivity`를 실행해 줘." (대상을 명확히 지정)
* **묵시적 인텐트**: "나는 **'웹 서핑(의도)'**을 하고 싶어. 이걸 할 수 있는 **아무 앱이나** 실행해 줘." (대상을 지정하지 않고 '의도'만 전달)
* 안드로이드 OS가 이 '의도'를 처리할 수 있는 다른 앱(크롬, 전화 앱 등)을 찾아 실행시켜 준다.

#### 주요 Action 예시

1.  **웹 브라우저 열기:**
    * `new Intent(Intent.ACTION_VIEW, Uri.parse("http://..."))`
2.  **전화 다이얼 열기:**
    * `new Intent(Intent.ACTION_DIAL, Uri.parse("tel://..."))`
3.  **공유하기 창 띄우기:**
    * `new Intent(Intent.ACTION_SEND)`
    * `intent.setType("text/plain");`
    * `intent.putExtra(Intent.EXTRA_TEXT, "공유할 내용");`
