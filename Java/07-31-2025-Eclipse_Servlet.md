# [TIL] 서블릿 로그인 기능 리팩토링: 역할과 책임의 분리

## 2025년 07월 31일

### 학습 목표

하나의 서블릿에 모든 기능이 혼재된 로그인 코드를 **MVC 패턴**에 기반하여 역할과 책임을 분리하고, 데이터베이스 설정 정보를 외부 파일로 분리하며, 최종적으로 **커넥션 풀(Connection Pool)**과 **상태 유지 기술(쿠키, 세션)**을 적용하여 **유지보수성과 성능, 사용성이 높은 구조**로 개선하는 과정을 학습한다.

---

## 리팩토링 과정

### Step 1: 역할 분리 - DAO와 VO 패턴 적용

초기 코드는 하나의 서블릿 클래스가 요청 처리, 비즈니스 로직, 데이터베이스 접근, 응답 화면 생성 등 모든 역할을 담당하고 있었다. 이를 해결하기 위해 각 클래스의 책임을 명확히 분리했다.

#### 왜 분리해야 하는가?

- **관심사의 분리 (Separation of Concerns)**: 각 클래스는 하나의 책임만 갖게 되어 코드 이해가 쉬워진다.
- **유지보수성 향상**: 특정 기능(DB, View, Logic)을 수정할 때 해당 파일만 집중해서 볼 수 있어 수정이 용이하고 실수를 줄일 수 있다.
- **코드 재사용성 증가**: `UserDao`나 `UserVO`는 다른 기능에서도 재사용할 수 있는 독립적인 부품이 된다.

#### 파일별 역할 정의

- `UserVO.java` (Value Object): 데이터 보관 및 운반.
- `UserDao.java` (Data Access Object): 데이터베이스 접근 전담.
- `LoginBeanVODao.java` (Servlet - Controller): 요청/응답 처리 및 흐름 제어.

---

### Step 2: 종속성 분리 - DB 정보를 `web.xml`로 이동

1단계에서 `UserDao`는 여전히 코드 내부에 DB 접속 정보를 하드코딩으로 가지고 있었다. 이를 해결하기 위해 DB 정보를 서블릿의 **초기화 파라미터(Init-Parameter)**를 사용하여 `web.xml`로 분리했다.

#### 왜 분리해야 하는가?

- **유연성 확보**: DB 정보 변경 시 자바 코드 수정 없이 `web.xml` 설정 파일만 변경하면 되므로, 개발/테스트/운영 환경에 따라 쉽게 전환할 수 있다.
- **보안**: 민감한 정보를 소스 코드로부터 분리하여 관리할 수 있다.

#### 변경된 흐름과 파일별 역할

1.  **`web.xml`**: `<init-param>`을 사용하여 DB 접속 정보를 정의한다.
2.  **`LoginBeanInitParam.java` (Servlet)**: `init()` 메서드에서 `web.xml`의 DB 정보를 읽어와 멤버 변수에 저장한다.
3.  **`UserInitParamDao.java` (DAO)**: 모든 DB 접속 정보를 서블릿으로부터 **메서드 파라미터로 전달받아** 사용한다.

---

### Step 3: 성능 향상 - 커넥션 풀(Connection Pool) 적용

2단계까지는 사용자의 요청이 있을 때마다 DB 커넥션을 새로 생성하고 닫는 과정을 반복했다. 이 과정은 비용이 큰 작업이므로, 동시 접속자가 많아지면 시스템 성능에 부하를 준다. 이를 해결하기 위해 **커넥션 풀**을 도입했다.

#### 왜 필요한가?

- **성능 및 응답 속도 향상**: 미리 생성된 DB 커넥션을 재사용함으로써 매번 커넥션을 생성하고 해제하는 비용을 없앤다.
- **자원 효율성 증대**: 한정된 수의 커넥션을 여러 사용자가 효율적으로 공유하므로, 서버 자원의 고갈을 방지한다.

#### 변경된 흐름과 파일별 역할

1.  **`OracleConnectionPool.java` (커넥션 풀 관리자)**
    - **역할**: DB 커넥션 풀을 생성하고 관리하는 전담 클래스.
    - **설명**: **싱글턴 패턴(Singleton Pattern)**으로 설계하여 애플리케이션 전체에서 단 하나의 커넥션 풀 인스턴스만 존재하도록 보장한다.
2.  **`UserPoolDao.java` (DAO)**
    - **역할**: `OracleConnectionPool`에서 커넥션을 **대여(getConnection)**하고 **반납(close)**하여 DB 작업을 수행한다.
3.  **`LoginBeanPool.java` (Servlet - Controller)**
    - **역할**: `UserPoolDao`를 사용하여 비즈니스 로직을 처리한다.

---

### Step 4: 상태 유지 - 쿠키(Cookie)와 세션(Session)

HTTP 프로토콜은 **비상태성(Stateless)**이라는 특징이 있어, 서버는 클라이언트의 이전 요청을 기억하지 못한다. 따라서 "로그인 유지", "장바구니" 같은 기능을 구현하려면 사용자의 상태를 어딘가에 저장해야 한다. 이때 사용하는 대표적인 기술이 쿠키와 세션이다.

#### 쿠키와 세션 비교

| 구분 | 쿠키 (Cookie) | 세션 (Session) |
| :--- | :--- | :--- |
| **저장 위치** | **클라이언트 (웹 브라우저)** | **서버** |
| **데이터 형태** | 문자열만 가능 (Key-Value) | 모든 객체 타입 가능 (Object) |
| **보안** | 클라이언트에 저장되므로 보안에 취약 | 서버에 저장되므로 상대적으로 안전 |
| **생명주기** | `setMaxAge()`로 설정 가능, 브라우저 종료 시 삭제되거나 파일로 유지 | 서버에서 설정한 시간 동안 유지, 브라우저 종료 시 보통 만료 |
| **속도** | 클라이언트에 저장되므로 빠름 | 서버에 부하를 줄 수 있음 |
| **핵심 원리** | 서버가 발행한 '티켓'을 클라이언트가 계속 가지고 다니는 방식 | 서버가 '보관증(세션 ID)'을 클라이언트에게 주고, 클라이언트는 보관증으로 서버의 정보를 이용하는 방식 |

#### 사용법 예시

-   **쿠키 (Cookie)**: 아이디 저장, 오늘 하루 보지 않기 등 보안에 민감하지 않은 정보에 사용.

    ```java
    // 쿠키 생성 및 클라이언트에 전송
    Cookie cookie = new Cookie("userId", "gildong");

    // 쿠키 유효기간(생명주기) 설정
    cookie.setMaxAge(60*60*24); // 유효기간을 1일로 설정 (초 단위)
    response.addCookie(cookie);
    ```

    **`setMaxAge()` 값의 의미**
    -   **양수 (예: `60*60*24`)**: 해당 시간(초)만큼 쿠키가 클라이언트 PC의 파일로 저장됩니다. 브라우저를 껐다 켜도 쿠키가 유지됩니다.
    -   **음수 (예: `-1`, 기본값)**: '세션 쿠키'라고 부릅니다. 쿠키가 파일로 저장되지 않고 브라우저의 메모리에만 존재하며, 브라우저를 종료하면 쿠키도 함께 삭제됩니다.
    -   **0**: 쿠키를 즉시 삭제하라는 의미입니다. 기존에 있던 쿠키를 만료시키고 싶을 때 사용합니다. (예: 로그아웃 시 '아이디 저장' 쿠키 삭제)

    ```java
    // 클라이언트로부터 쿠키 읽기
    Cookie[] cookies = request.getCookies();
    if (cookies != null) {
        for (Cookie c : cookies) {
            if (c.getName().equals("userId")) {
                String userId = c.getValue();
            }
        }
    }
    ```

-   **세션 (Session)**: 로그인 정보, 장바구니 등 보안이 중요하고 복잡한 정보를 유지할 때 사용.

    ```java
    // 세션 객체 얻기 및 데이터 저장 (로그인 성공 시)
    HttpSession session = request.getSession(); // 세션이 없으면 새로 생성, 있으면 기존 세션 반환
    session.setAttribute("loginUser", userVO); // userVO 객체를 세션에 저장
    session.setMaxInactiveInterval(30 * 60); // 세션 유효시간 30분으로 설정

    // 세션에서 데이터 읽기 (다른 페이지에서)
    HttpSession session = request.getSession(false); // 세션이 없으면 null 반환
    if (session != null) {
        UserVO loginUser = (UserVO) session.getAttribute("loginUser");
    }

    // 세션 무효화 (로그아웃 시)
    session.invalidate();
    ```

---

## 최종 결론

| 단계 | 구조 | 장점 |
| :--- | :--- | :--- |
| **초기** | 단일 서블릿 | 간단하지만 확장이 어렵고 유지보수가 힘듦 |
| **1단계** | `Controller` + `DAO` + `VO` | 역할 분리로 가독성 및 유지보수성 향상 |
| **2단계** | `Controller` + `DAO` + `VO` + `web.xml` | DB 종속성 제거로 유연성 및 보안 향상 |
| **3단계** | `Controller` + `DAO(Pool)` + `VO` + `PoolManager` | 커넥션 풀 적용으로 성능 및 자원 효율성 극대화 |
| **4단계** | 위 구조 + **쿠키/세션** | 상태 유지를 통해 로그인 등 연속적인 사용자 경험 제공 |

이번 리팩토링을 통해 **관심사의 분리**와 **의존성 주입(DI)**, 그리고 **커넥션 풀**과 **싱글턴 디자인 패턴**, **상태 관리(쿠키/세션)**까지 웹 개발의 핵심적인 개념들을 서블릿 환경에서 직접 구현해볼 수 있었다. 잘 설계된 구조는 당장의 코드 몇 줄을 줄이는 것보다 장기적으로 애플리케이션을 더 건강하고 확장성 있게 만든다는 것을 알게 되었다.
