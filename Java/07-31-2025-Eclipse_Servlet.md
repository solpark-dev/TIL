# [TIL] 서블릿 로그인 기능 리팩토링: 역할과 책임의 분리

## 2025년 07월 31일

### 학습 목표

하나의 서블릿에 모든 기능이 혼재된 로그인 코드를 **MVC 패턴**에 기반하여 역할과 책임을 분리하고, 데이터베이스 설정 정보를 외부 파일로 분리하며, 최종적으로 **커넥션 풀(Connection Pool)**과 **상태 유지 기술(쿠키, 세션)**을 적용하여 **유지보수성과 성능, 사용성이 높은 구조**로 개선하는 과정을 학습함.

---

## 리팩토링 과정

### Step 1: 역할 분리 - DAO와 VO 패턴 적용

초기 코드는 하나의 서블릿 클래스가 요청 처리, 비즈니스 로직, 데이터베이스 접근, 응답 화면 생성 등 모든 역할을 담당함. 이를 해결하기 위해 각 클래스의 책임을 명확히 분리함.

#### 왜 분리해야 하는가?

- **관심사의 분리 (Separation of Concerns)**: 각 클래스는 하나의 책임만 갖게 되어 코드 이해가 쉬워짐.
- **유지보수성 향상**: 특정 기능(DB, View, Logic)을 수정할 때 해당 파일만 집중해서 볼 수 있어 수정이 용이하고 실수를 줄임.
- **코드 재사용성 증가**: `UserDao`나 `UserVO`는 다른 기능에서도 재사용할 수 있는 독립적인 부품이 됨.

#### 파일별 역할 정의

- `UserVO.java` (Value Object): 데이터 보관 및 운반.
- `UserDao.java` (Data Access Object): 데이터베이스 접근 전담.
- `LoginBeanVODao.java` (Servlet - Controller): 요청/응답 처리 및 흐름 제어.

---

### Step 2: 종속성 분리 - DB 정보를 `web.xml`로 이동

1단계에서 `UserDao`는 여전히 코드 내부에 DB 접속 정보를 하드코딩으로 가지고 있었음. 이를 해결하기 위해 DB 정보를 서블릿의 **초기화 파라미터(Init-Parameter)**를 사용하여 `web.xml`로 분리함.

#### 왜 분리해야 하는가?

- **유연성 확보**: DB 정보 변경 시 자바 코드 수정 없이 `web.xml` 설정 파일만 변경하면 되므로, 개발/테스트/운영 환경에 따라 쉽게 전환 가능.
- **보안**: 민감한 정보를 소스 코드로부터 분리하여 관리 가능.

#### 변경된 흐름과 파일별 역할

1.  **`web.xml`**: `<init-param>`을 사용하여 DB 접속 정보를 정의함.
2.  **`LoginBeanInitParam.java` (Servlet)**: `init()` 메서드에서 `web.xml`의 DB 정보를 읽어와 멤버 변수에 저장함.
3.  **`UserInitParamDao.java` (DAO)**: 모든 DB 접속 정보를 서블릿으로부터 **메서드 파라미터로 전달받아** 사용함.

---

### Step 3: 성능 향상 - 커넥션 풀(Connection Pool) 적용

2단계까지는 사용자의 요청이 있을 때마다 DB 커넥션을 새로 생성하고 닫는 과정을 반복했음. 이 과정은 비용이 큰 작업이므로, 동시 접속자가 많아지면 시스템 성능에 부하를 줌. 이를 해결하기 위해 **커넥션 풀**을 도입함.

#### 왜 필요한가?

- **성능 및 응답 속도 향상**: 미리 생성된 DB 커넥션을 재사용함으로써 매번 커넥션을 생성하고 해제하는 비용을 없앰.
- **자원 효율성 증대**: 한정된 수의 커넥션을 여러 사용자가 효율적으로 공유하므로, 서버 자원의 고갈을 방지함.

#### 변경된 흐름과 파일별 역할

1.  **`OracleConnectionPool.java` (커넥션 풀 관리자)**
    - **역할**: DB 커넥션 풀을 생성하고 관리하는 전담 클래스.
    - **설명**: **싱글턴 패턴(Singleton Pattern)**으로 설계하여 애플리케이션 전체에서 단 하나의 커넥션 풀 인스턴스만 존재하도록 보장함.
2.  **`UserPoolDao.java` (DAO)**
    - **역할**: `OracleConnectionPool`에서 커넥션을 **대여(getConnection)**하고 **반납(close)**하여 DB 작업을 수행함.
3.  **`LoginBeanPool.java` (Servlet - Controller)**
    - **역할**: `UserPoolDao`를 사용하여 비즈니스 로직을 처리함.

---

### Step 4: 상태 유지 - 쿠키(Cookie)와 세션(Session)

HTTP 프로토콜은 **비상태성(Stateless)**이라는 특징이 있어, 서버는 클라이언트의 이전 요청을 기억하지 못함. 따라서 "로그인 유지", "장바구니" 같은 기능을 구현하려면 사용자의 상태를 어딘가에 저장해야 함. 이때 사용하는 대표적인 기술이 쿠키와 세션임.

#### 쿠키와 세션 비교

| 구분 | 쿠키 (Cookie) | 세션 (Session) |
| :--- | :--- | :--- |
| **저장 위치** | **클라이언트 (웹 브라우저)** | **서버** |
| **데이터 형태** | 문자열만 가능 (Key-Value) | 모든 객체 타입 가능 (Object) |
| **보안** | 클라이언트에 저장되므로 보안에 취약 | 서버에 저장되므로 상대적으로 안전 |
| **생명주기** | `setMaxAge()`로 설정 가능, 브라우저 종료 시 삭제되거나 파일로 유지 | 서버에서 설정한 시간 동안 유지, 브라우저 종료 시 보통 만료 |
| **속도** | 클라이언트에 저장되므로 빠름 | 서버에 부하를 줄 수 있음 |
| **핵심 원리** | 서버가 발행한 '티켓'을 클라이언트가 계속 가지고 다니는 방식 | 서버가 '보관증(세션 ID)'을 클라이언트에게 주고, 클라이언트는 보관증으로 서버의 정보를 이용하는 방식 |

#### 사용법 예시

-   **쿠키 (Cookie)**: 아이디 저장, 오늘 하루 보지 않기 등 보안에 민감하지 않은 정보에 사용됨.

    **한글 및 특수문자 처리 (인코딩)**
    쿠키 값은 US-ASCII 문자셋만 지원하므로, 한글이나 공백, 특수문자를 값으로 사용하려면 반드시 인코딩/디코딩 처리를 해야 데이터가 깨지지 않음.

    ```java
    import java.net.URLEncoder;
    import java.net.URLDecoder;

    // 1. 쿠키 생성 시: 한글 값을 UTF-8로 인코딩
    String userName = "홍길동";
    String encodedName = URLEncoder.encode(userName, "UTF-8");
    Cookie cookie = new Cookie("userName", encodedName);

    // 2. 쿠키 유효기간(생명주기) 설정
    cookie.setMaxAge(60*60*24); // 유효기간을 1일로 설정 (초 단위)
    response.addCookie(cookie);
    ```

    **`setMaxAge()` 값의 의미**
    -   **양수 (예: `60*60*24`)**: 해당 시간(초)만큼 쿠키가 클라이언트 PC의 파일로 저장됨. 브라우저를 껐다 켜도 쿠키가 유지됨.
    -   **음수 (예: `-1`, 기본값)**: '세션 쿠키'라고 부름. 쿠키가 파일로 저장되지 않고 브라우저의 메모리에만 존재하며, 브라우저를 종료하면 쿠키도 함께 삭제됨.
    -   **0**: 쿠키를 즉시 삭제하라는 의미임. 기존에 있던 쿠키를 만료시키고 싶을 때 사용됨. (예: 로그아웃 시 '아이디 저장' 쿠키 삭제)

    ```java
    // 3. 클라이언트로부터 쿠키 읽기: 읽은 값을 UTF-8로 디코딩
    Cookie[] cookies = request.getCookies();
    if (cookies != null) {
        for (Cookie c : cookies) {
            if (c.getName().equals("userName")) {
                String encodedValue = c.getValue();
                String decodedName = URLDecoder.decode(encodedValue, "UTF-8");
                // decodedName 변수에 "홍길동"이 저장됨
            }
        }
    }
    ```

-   **세션 (Session)**: 로그인 정보, 장바구니 등 보안이 중요하고 복잡한 정보를 유지할 때 사용됨.

    ```java
    // 세션 객체 얻기 및 데이터 저장 (로그인 성공 시)
    HttpSession session = request.getSession(); // 세션이 없으면 새로 생성, 있으면 기존 세션 반환
    session.setAttribute("loginUser", userVO); // userVO 객체를 세션에 저장
    session.setMaxInactiveInterval(30 * 60); // 세션 유효시간 30분으로 설정

    // 세션에서 데이터 읽기 (다른 페이지에서)
    HttpSession session = request.getSession(false); // 세션이 없으면 null 반환
    if (session != null) {
        UserVO loginUser = (UserVO) session.getAttribute("loginUser");
    }

    // 세션 무효화 (로그아웃 시)
    session.invalidate();
    ```

---

## 최종 결론

| 단계 | 구조 | 장점 |
| :--- | :--- | :--- |
| **초기** | 단일 서블릿 | 간단하지만 확장이 어렵고 유지보수가 힘듦 |
| **1단계** | `Controller` + `DAO` + `VO` | 역할 분리로 가독성 및 유지보수성 향상 |
| **2단계** | `Controller` + `DAO` + `VO` + `web.xml` | DB 종속성 제거로 유연성 및 보안 향상 |
| **3단계** | `Controller` + `DAO(Pool)` + `VO` + `PoolManager` | 커넥션 풀 적용으로 성능 및 자원 효율성 극대화 |
| **4단계** | 위 구조 + **쿠키/세션** | 상태 유지를 통해 로그인 등 연속적인 사용자 경험 제공 |

이번 리팩토링을 통해 **관심사의 분리**와 **의존성 주입(DI)**, 그리고 **커넥션 풀**과 **싱글턴 디자인 패턴**, **상태 관리(쿠키/세션)**까지 웹 개발의 핵심적인 개념들을 서블릿 환경에서 직접 구현해볼 수 있었음. 잘 설계된 구조는 당장의 코드 몇 줄을 줄이는 것보다 장기적으로 애플리케이션을 더 건강하고 확장성 있게 만든다는 것을 알게 됨.

---

## 주요 웹 개발 용어 정리

### 아키텍처 (Architecture)

-   **Presentation Layer (표현 계층)**
    -   사용자에게 보여지는 화면을 담당하는 영역. 즉, 클라이언트(웹 브라우저) 쪽을 의미함.
    -   HTML, CSS, JavaScript를 통해 사용자 인터페이스(UI)를 구성하고 사용자의 입력을 받음.

-   **Business Logic Layer (비즈니스 로직 계층)**
    -   애플리케이션의 핵심적인 로직을 처리하는 영역.
    -   사용자의 요청을 받아 데이터를 가공하거나, 특정 조건에 따라 다른 동작을 하도록 제어함. `DAO`를 통해 데이터베이스에 접근하여 데이터를 조회하거나 수정하는 작업 등이 이 계층에서 이루어짐.

-   **2-Layer Architecture (모델 1 아키텍처)**
    -   표현 계층(JSP 등)과 비즈니스 로직 계층(JavaBean, DAO 등)의 두 가지 계층으로만 구성된 단순한 구조임.
    -   JSP 페이지 안에서 자바 코드를 사용하여 직접 DB에 접근하고 로직을 처리하는 방식이 대표적임. 구조가 간단하여 소규모 프로젝트에 빠르게 적용할 수 있지만, 화면과 로직이 섞여 있어 복잡한 프로젝트에서는 유지보수가 어려움.

### 객체 및 패턴 (Object & Pattern)

-   **VO (Value Object)**
    -   데이터 그 자체를 표현하기 위한 객체. 계층 간 데이터를 전달할 때 사용하는 '값 객체' 또는 '데이터 보관함'임.

-   **DAO (Data Access Object)**
    -   데이터베이스에 접근하는 로직을 전담하는 객체. 비즈니스 로직과 DB 로직을 분리하여 코드의 재사용성과 유지보수성을 높임.

-   **Connection Pool (커넥션 풀)**
    -   데이터베이스 커넥션을 미리 여러 개 만들어 '풀(Pool)'에 저장해두고, 필요할 때마다 빌려 쓰고 반납하는 방식임. 매번 커넥션을 생성하는 비용을 줄여 애플리케이션의 성능을 크게 향상시킴.

-   **Flag (플래그)**
    -   특정 상태를 기록하고 구분하기 위한 변수나 데이터. 예를 들어, 회원 탈퇴 시 실제 데이터를 DB에서 삭제(`DELETE`)하는 대신, `is_deleted` 같은 컬럼의 값을 'Y'로 변경하여 '삭제된 상태'임을 표시하는 방식을 '소프트 삭제(Soft Delete)'라고 하며, 이때 사용되는 `is_deleted` 컬럼이 플래그의 일종임.

### 설정 및 데이터 (Configuration & Data)

-   **Meta Data (메타 데이터)**
    -   '데이터를 위한 데이터'. 즉, 데이터 그 자체가 아니라 데이터를 설명해주는 데이터를 의미함.
    -   `web.xml` 파일이 대표적인 예시임. 이 파일은 서블릿 클래스(`데이터`)가 어떤 URL과 매핑되는지, 어떤 초기값을 갖는지 등을 `설명`해주는 메타 데이터임.

-   **web.xml (배포 서술자, Deployment Descriptor)**
    -   웹 애플리케이션의 설정 파일. 웹 서버(Tomcat 등)는 이 파일을 읽어 서블릿, 필터, 리스너 등을 어떻게 설정하고 실행할지 파악함.
    -   서블릿의 `ServletConfig` 객체는 이 `web.xml`에 정의된 내용을 바탕으로 생성되므로, `web.xml`은 `ServletConfig`의 정보를 추상화하고 캡슐화한 외부 설정 파일이라고 볼 수 있음.
