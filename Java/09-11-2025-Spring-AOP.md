# Ⅰ. AOP의 핵심 목표: 관심사의 분리 (Separation of Concerns)

AOP를 배우는 가장 근본적인 이유는 **관심사의 분리**를 통해 깨끗하고 유지보수하기 좋은 코드를 작성하기 위함이다.

### 1. 핵심 관심사 (Core Concern)
- **정의**: 모듈의 **본질적인 존재 이유**가 되는 고유한 비즈니스 로직.
- **예시**: `주문 서비스`의 `결제 처리`, `게시판 서비스`의 `글쓰기 기능` 등.
- 이 기능이 없다면 해당 모듈은 의미가 없다.

### 2. 공통 관심사 (Cross-Cutting Concern)
- **정의**: 비즈니스 로직과 직접적인 관련은 없지만, **여러 모듈에 공통적으로 필요한 부가 기능**.
- **예시**: 로깅, 트랜잭션 관리, 보안(인증/인가), 성능 측정 등.
- 이 기능들은 애플리케이션 전반에 흩어져서 반복적으로 나타나는 특징이 있다.

### 3. 왜 분리해야 하는가?
AOP가 없다면, 하나의 메소드 안에 핵심 관심사와 공통 관심사 코드가 뒤섞이게 된다.



```java
// AOP가 없을 때의 코드
public void placeOrder() {
    log.info("주문 시작...");      // 공통 관심사
    beginTransaction();         // 공통 관심사
    try {
        processPayment();       // ★핵심 관심사★
        updateInventory();      // ★핵심 관심사★
        commit();               // 공통 관심사
    } catch(Exception e) {
        rollback();             // 공통 관심사
        log.error("주문 실패!");   // 공통 관심사
    }
}
```

- **문제점**: 코드가 복잡해지고, 공통 기능에 변경이 생기면 관련된 모든 코드를 찾아 수정해야 하는 **유지보수의 지옥**이 펼쳐진다.
- **AOP의 해법**: 공통 관심사를 **'Aspect'**라는 별도의 모듈로 빼내고, 원하는 곳에 동적으로 주입(Weaving)하여 이 문제를 해결한다.

---


# Ⅱ. AOP 발전 과정: 문제 해결의 여정

오늘 살펴본 예제들은 이 '관심사의 분리'를 어떻게 더 효율적이고 세련되게 할 수 있는지에 대한 발전의 역사이다.

### 1단계: AOP 이전 - 수동 작업의 시대
- `MessageImpl.java`에 핵심 로직과 `System.out.println`이라는 공통 로직이 섞여 있던 최초의 상태. 모든 것을 개발자가 직접 처리했다.

### 2단계: 정적 프록시 패턴 - 최초의 자동화 시도
- `MessageImplProxy.java`
- **개념**: 실제 객체(`Target`)를 대신하는 대리인(`Proxy`)을 만들어, 대리인이 공통 기능을 처리하고 원본 객체는 핵심 기능에만 집중하도록 하는 디자인 패턴.
- **성과**: 관심사 분리에 성공했다.
- **한계**: 프록시를 적용할 클래스마다 개발자가 직접 프록시 클래스를 만들어야 해서 매우 번거롭다.

### 3단계: 다이내믹 프록시 - 재사용성의 혁명
- `LoggingHandler.java` (InvocationHandler), `Proxy.newProxyInstance`
- **개념**: 프로그램 실행 중에(Runtime) JVM이 동적으로 프록시 객체를 만들어주는 자바 표준 API.
- **동작**: 공통 로직을 담은 `InvocationHandler`를 한 번만 만들면, 어떤 인터페이스를 구현한 객체든 즉석에서 프록시로 감쌀 수 있다.
- **성과**: 반복적인 프록시 클래스 작성이 사라져 재사용성이 극대화되었다. **스프링 AOP의 근간이 되는 기술**이다.

### 4단계: Spring AOP (XML 기반) - 선언적 프로그래밍의 시작
- **개념**: 다이내믹 프록시 생성 과정을 스프링 컨테이너가 대신 처리해주고, 개발자는 XML에 "어떻게 동작할지"만 선언하면 되는 방식.
- **발전 순서**:
    1.  **`ProxyFactoryBean`**: Target, Advice, Interface를 직접 지정하여 수동으로 프록시를 조립.
    2.  **`Advisor`와 `Pointcut`**: Advice(무엇을)와 Pointcut(어디에)을 Advisor로 묶어 AOP의 단위를 구성. Pointcut 표현식을 통해 원하는 메소드만 정밀 타격이 가능해졌다.
    3.  **`DefaultAdvisorAutoProxyCreator`**: 컨테이너 안의 모든 Advisor를 감지하고, Pointcut 조건에 맞는 모든 Bean을 **자동으로** 프록시로 만들어주는 '자동 순찰 로봇'. `ProxyFactoryBean`을 일일이 선언할 필요가 없어졌다.

### 5단계: Spring AOP (Annotation 기반) - 완전 자동화의 완성
- `TestAspectJ01.java` (`@Aspect`), `<aop:aspectj-autoproxy/>`
- **개념**: AOP 설정을 XML이 아닌, **자바 어노테이션**으로 코드에 직접 표현하는 현대적인 방식.
- **특징**:
    - **`@Aspect`**: POJO 클래스가 AOP의 '스마트 설계도'임을 선언.
    - **`@Pointcut`, `@Before`, `@Around` 등**: '어디에', '무엇을' 할지를 코드 안에서 직관적으로 설정.
    - **`<aop:aspectj-autoproxy/>`**: XML에 이 한 줄을 추가하는 것만으로, 스프링이 모든 `@Aspect` Bean을 찾아 AOP를 자동으로 구성하는 'AI 공장 가동 스위치'.
 
  # Ⅲ. AOP 핵심 용어 완전 정복

| 용어 | 상세 설명 | 비유 |
| :--- | :--- | :--- |
| **타겟 (Target)** | **부가 기능(Advice)이 적용될 대상이 되는, 핵심 비즈니스 로직을 담은 원본 객체.** AOP의 관점에서는 핵심 기능에만 집중하는 순수한 객체여야 한다. | 보호받는 VIP, 실제 일을 하는 일꾼 |
| **어드바이스 (Advice)** | **언제(예: 메소드 실행 전/후), 무엇을(예: 로깅, 트랜잭션) 할지를 정의한 부가 기능 코드.** `Before`, `After`, `Around` 등 다양한 종류가 있다. | VIP를 경호하는 경호원의 '행동 지침' |
| **조인 포인트 (Join Point)** | **Advice가 끼어들 수 있는 모든 실행 지점.** 메소드 호출, 필드 값 변경 등 다양하지만, 스프링 AOP에서는 프록시 기반의 한계로 **메소드 실행 시점**만 지원한다. | 경호원이 VIP를 경호할 수 있는 모든 잠재적 위치 (복도, 엘리베이터 앞, 주차장 등) |
| **포인트컷 (Pointcut)** | **수많은 조인 포인트 중에서, Advice를 실제로 적용할 특정 위치를 선별하는 정밀한 규칙.** AspectJ 표현식을 사용하여 메소드 시그니처 등을 기준으로 정의한다. | 수많은 경호 위치 중, "엘리베이터 앞에서만" 경호하라는 '작전 계획' |
| **애스펙트 (Aspect) / 어드바이저 (Advisor)** | **Advice(무엇을)와 Pointcut(어디에)을 하나의 단위로 묶은 모듈.** AOP의 가장 기본이 되는 모듈이며, 공통 관심사를 완벽하게 모듈화한 결과물이다. | '행동 지침(Advice)'과 '작전 계획(Pointcut)'을 합친 하나의 완전한 '작전명' |
| **프록시 (Proxy)** | **Target을 감싸서 Advice를 실행하는 대리인 객체.** 클라이언트는 Target을 직접 호출하는 것이 아니라 Proxy를 호출하며, Proxy는 Advice를 먼저 수행한 후 Target을 호출한다. | VIP를 대신해 외부 요청을 먼저 받는 '비서' 또는 '경호팀장' |
| **위빙 (Weaving)** | **Advice를 Target의 지정된 Pointcut에 적용하여 Proxy 객체를 만드는 과정** 그 자체를 의미한다. 컴파일 시, 클래스 로딩 시, 런타임 시에 일어날 수 있으며 스프링은 '런타임 위빙'을 사용한다. | 경호팀(Advice)을 VIP(Target)에게 배치하여 하나의 경호팀(Proxy)을 완성하는 '배치 과정' |
