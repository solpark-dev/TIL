
# TIL (Today I Learned) - 2025-09-09

## MyBatis에서 Spring IoC로: 설정의 진화와 계층형 아키텍처 구축

오늘은 수동으로 의존성을 관리하는 MyBatis 애플리케이션에서 시작하여, 최종적으로 Spring 프레임워크의 어노테이션 기반 IoC 컨테이너를 활용하는, 깨끗하고 체계적인 구조로 진화시키는 전 과정을 학습했습니다.

---

### ## 1. 동적 SQL과 MyBatis의 기본

MyBatis를 사용하여, 검색 조건에 따라 SQL이 동적으로 변하는 **동적 SQL**을 만들었습니다.

-   **`<if>`, `<where>`, `<foreach>`**: 조건이나 리스트 데이터를 기반으로 SQL을 유연하게 조립하는 방법을 배웠습니다.
-   **`<choose>`, `<when>`, `<otherwise>`**: 여러 조건 분기를 처리하는 방법을 배웠습니다.
-   **`jdbcType`**: `null` 값이 원인이 되어 발생하는 데이터베이스 에러(예: `부적합한 열 유형`)를 막기 위해, 파라미터에 데이터 타입을 명시하는 중요성을 이해했습니다.

> **학습 포인트**: 데이터베이스 에러 로그 분석을 통해 문제의 원인을 찾아내고 해결하는 능력을 길렀습니다. (예: `Unsupported class file major version 61` 에러는 JDK와 프레임워크의 버전 불일치가 원인임을 파악하고, 프로젝트의 자바 컴파일러 버전을 11로 조정하여 해결했습니다.)

---

### ## 2. 계층형 아키텍처의 도입 (DAO와 Service)

코드의 역할을 분리하고 더 체계적인 구조로 만들기 위해 **DAO 패턴**과 **Service 레이어 패턴**을 도입했습니다.

1.  **DAO (Data Access Object) 레이어**
    -   `UserDao` 인터페이스와 `UserDaoImpl` 구현 클래스를 만들었습니다.
    -   데이터베이스 접근(CRUD)에 관한 모든 로직을 캡슐화하여 영속성 로직을 분리했습니다.
    -   `NAMESPACE` 상수를 사용하여 유지보수성과 가독성을 높였습니다.

2.  **Service 레이어**
    -   `UserService` 인터페이스와 `UserServiceImpl` 구현 클래스를 만들었습니다.
    -   DAO를 직접 호출하는 대신 Service를 통해 비즈니스 로직(트랜잭션 관리, 데이터 검증 등)을 수행하는 중간 계층을 구축했습니다.

---

### ## 3. Spring IoC 컨테이너로의 전환

객체 생성과 의존성 관리를 개발자로부터 프레임워크에 위임하는 **IoC(Inversion of Control, 제어의 역전)**를 학습했습니다.

#### **단계 1: XML 기반 설정**

-   `commonservice.xml`과 `userservice.xml`을 사용하여 `<bean>` 태그로 컴포넌트를 정의하고, `<property>` 태그로 의존성을 **수동으로 주입**했습니다.
-   이는 스프링이 어떻게 객체를 조립하는지 이해하는 기초가 되었습니다.

#### **단계 2: 어노테이션 기반 설정**

-   XML 설정을 최소화하고, 자바 코드에 직접 메타데이터를 추가하는 **어노테이션** 방식으로 전환했습니다.
-   **`<context:component-scan>`**: 지정된 패키지를 스캔하여 어노테이션이 붙은 클래스를 자동으로 Bean으로 등록합니다.
-   **`@Repository`, `@Service`**: 각 클래스의 역할(DAO, Service)을 스프링에 알려주어 Bean으로 관리하게 합니다.
-   **`@Autowired`**: XML의 `<property>` 태그 대신, 필요한 의존성을 필드에 자동으로 주입합니다.

> **학습 포인트**: 직접 만든 클래스(`UserServiceImpl` 등)는 어노테이션으로 간단히 Bean 등록이 가능하지만, MyBatis의 `SqlSessionTemplate` 같은 **서드 파티(3rd-party) 라이브러리는 직접 수정할 수 없으므로, 여전히 XML에 `<bean>`으로 정의해야 한다**는 점을 이해했습니다.

---

### ## 용어 정리

-   **Component**: 인터페이스에 의해 캡슐화된, 재사용 가능한 소프트웨어 라이브러리 또는 단위. 독립적인 기능을 수행하는 부품입니다.
-   **IoC (Inversion of Control, 제어의 역전)**: 객체의 생성, 생명주기 관리 등 제어권을 개발자로부터 프레임워크(컨테이너)로 이전하는 디자인 원칙.
-   **DI (Dependency Injection, 의존성 주입)**: IoC를 구현하는 디자인 패턴 중 하나. 클래스가 필요로 하는 의존 객체를 외부(컨테이너)에서 주입(설정)해주는 방식.
-   **TDD (Test-Driven Development)**: 구현 코드를 작성하기 전에 테스트 케이스를 먼저 설계하고 작성하는 개발 방법론.
-   **어노테이션 (Annotation)**: `@` 기호로 시작하며, 코드에 추가하는 메타데이터(부가 정보). 컴파일러나 프레임워크에게 특정 기능이나 설정을 지시합니다.
    -   **`@Component`**: 스프링이 관리하는 범용 컴포넌트임을 나타내는 가장 기본적인 어노테이션.
    -   **`@Repository`**: 영속성 계층(DAO)을 위한 `@Component`. 데이터베이스 예외를 스프링 예외로 자동 변환해주는 기능이 포함됩니다.
    -   **`@Service`**: 비즈니스 로직 계층(Service)을 위한 `@Component`.
    -   **`@Controller`**: 프레젠테이션 계층(Controller)을 위한 `@Component`.
    -   **`@Autowired`**: 타입을 기준으로 필요한 의존성을 자동으로 주입하는 어노테이션. (`@Inject`도 JSR-330 표준으로 비슷한 기능을 합니다.)
