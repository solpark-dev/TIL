# TIL (2025-08-06)

## 주제: Model 2 아키텍처 리팩토링 - 커맨드 패턴(Command Pattern) 적용

오늘은 기존의 단일 `ControlServlet` 구조를 **커맨드 패턴**을 활용하여 리팩토링하는 작업을 진행했다. 이 리팩토링의 핵심 목표는 **요청 처리 로직을 분리하여 유지보수성과 확장성을 높이는 것**이다.

### 1. 리팩토링 이전의 구조 (As-Is)

하나의 서블릿(`ControlServlet`)이 모든 `*.do` 요청을 받았다. `service()` 메소드 내부에 긴 `if-else if` 블록이 존재하여, 요청 URI를 분석하고 각기 다른 비즈니스 로직을 직접 처리했다.

-   **문제점**:
    -   새로운 기능이 추가될 때마다 `if-else if` 구문을 계속 수정해야 한다 (OCP 위배).
    -   서블릿 하나의 크기가 비대해지고 복잡도가 높아져 가독성과 유지보수성이 떨어진다.

### 2. 리팩토링 이후의 구조 (To-Be)

커맨드 패턴을 적용하여 요청 처리 구조를 분산시켰다.

#### 주요 컴포넌트

1.  **`DispatcherServlet` (Front Controller)**
    -   모든 클라이언트의 요청을 받는 단일 진입점 역할은 유지한다.
    -   하지만 직접 로직을 처리하지 않고, 요청을 분석하여 해당 요청을 처리할 적절한 `Controller`에게 작업을 **분배(Dispatch)**하는 책임만 진다.

2.  **`Controller` 인터페이스**
    -   모든 커맨드 객체(개별 컨트롤러)들이 구현해야 할 표준 명세이다.
    -   `execute(req, res)`라는 단일 메소드를 정의하여, `DispatcherServlet`이 일관된 방식으로 각 컨트롤러를 호출할 수 있게 한다.

    ```java
    public interface Controller {
        public void execute(HttpServletRequest req, HttpServletResponse res)
        throws ServletException, IOException;
    }
    ```

3.  **개별 `Controller` 클래스 (Concrete Command)**
    -   `LogonController`, `HomeController` 등 실제 비즈니스 로직을 수행하는 클래스들이다.
    -   각 클래스는 `Controller` 인터페이스를 구현하며, `execute()` 메소드 안에 특정 요청 하나를 처리하기 위한 코드만 존재한다.

4.  **`ControllerMapping` (Invoker or Factory)**
    -   `DispatcherServlet`으로부터 요청받은 `action` 이름(e.g., "logon")에 해당하는 `Controller` 객체를 생성하여 반환하는 **팩토리(Factory)** 역할을 수행한다.
    -   **싱글톤 패턴**으로 설계하여 불필요한 객체 생성을 막고 일관된 매핑 정보를 유지한다.

    ```java
    // ControllerMapping.java 의 일부
    public Controller getController(String actionPage) {
        Controller controller = null;
        if(actionPage.equals("logon")) {
            controller = new LogonController();
        } else if(actionPage.equals("logonAction")){
            controller = new LogonActionController();
        } //...
        return controller;
    }
    ```

### 3. 리팩토링의 효과

-   **관심사의 분리 (Separation of Concerns)**: `DispatcherServlet`은 '요청 분배', 각 `Controller` 클래스는 '비즈니스 로직 처리'라는 명확한 역할 분리가 이루어졌다.
-   **개방-폐쇄 원칙 (Open-Closed Principle)**: 새로운 기능(e.g., `logout.do`)을 추가할 때, 기존 `DispatcherServlet` 코드를 수정할 필요 없이 새로운 `LogoutController` 클래스를 추가하고 `ControllerMapping`에 등록만 하면 된다. **확장에는 열려있고, 변경에는 닫혀있는** 좋은 구조가 되었다.
-   **유지보수성 및 가독성 향상**: 코드의 양이 각 기능별로 분산되어 특정 로직을 찾고 수정하기가 매우 용이해졌다.

### 4. 다음 단계

현재 `ControllerMapping` 클래스 내의 `if-else` 구문도 개선의 여지가 있다. 다음 단계에서는 이 매핑 정보를 외부 `.properties` 파일로 분리하여, 자바 코드의 수정 없이 요청과 컨트롤러를 매핑할 수 있도록 개선할 예정이다.
